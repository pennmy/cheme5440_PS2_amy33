#### Build the stoichiometric array

pidx = 5

function ingredients(path::String)
	
	# this is from the Julia source code (evalfile in base/loading.jl)
	# but with the modification that it returns the module instead of the last object
	name = Symbol("lib")
	m = Module(name)
	Core.eval(m,
        Expr(:toplevel,
             :(eval(x) = $(Expr(:core, :eval))($name, x)),
             :(include(x) = $(Expr(:top, :include))($name, x)),
             :(include(mapexpr::Function, x) = $(Expr(:top, :include))(mapexpr, $name, x)),
             :(include($path))))
	m
end

begin

	# import some packages -
	using PlutoUI
	using LinearAlgebra
	using RowEchelon
	using IterativeSolvers
	using Combinatorics
	using Plots
	using GLPK
	using PrettyTables
	
	# setup paths -
	const _PATH_TO_NOTEBOOK = pwd()
	const _PATH_TO_SRC = joinpath(_PATH_TO_NOTEBOOK,"src")

	# load the class lib as LectureLib -
	lib = ingredients(joinpath(_PATH_TO_SRC, "Include.jl"));

	# return -
	nothing
end

begin 

	# Setup a collection of reaction strings -
	reaction_array = Array{String,1}()

	# encode the reactions -
	# internal reactions -
	push!(reaction_array,"v₁, Aspartate+Citrulline, Argininosuccinate,false")
	push!(reaction_array,"v₂, Argininosuccinate, Fumarate+Arginine, false")
	push!(reaction_array,"v₃, Arginine, Ornithine+Urea, false")
	push!(reaction_array,"v₄, Ornithine+Carbamoyl Phosphate, Citrulline, false")
	push!(reaction_array,"v₅, Citrulline, Arginine, false")

	# exchange reactions 
	push!(reaction_array,"b₁, ∅, CarbamoylPhosphate, false")
	push!(reaction_array,"b₂, ∅, Aspartate, false")
	push!(reaction_array,"b₃, Fumarate, ∅, false")
	push!(reaction_array,"b₄, Urea, ∅, false")
	
	# compute the stoichiometric matrix -
	# the optional expand arguement = should we split reversible reactions? (default: false)
	(S, species_array, reaction_name_array) = lib.build_stoichiometric_matrix(reaction_array);
	#expand=true
	# show -
	nothing
	
end


(ℳ,ℛ) = size(S)

species_array

S


#### Convex analysis: extreme pathways
begin 

	# compute the extreme pathways Tableu -
	PM = lib.expa(S)
	
	# P constaints the extreme pathways (rows) and 𝒩 is the "balanced" array (should be all zeros) -
	P = PM[:,1:ℛ]
	𝒩 = PM[:,(ℛ+1):end]

	# show -
	nothing
end

size(P)

rank(P)
P

#### Reaction connectivity array (RCA)

function binary_stoichiometric_matrix(matrix::Array{Float64,2})::Array{Int64,2}

	# initialize -
	(ℳ,ℛ) = size(matrix)
	B = Array{Int64,2}(undef,ℳ,ℛ)

	for row_index ∈ 1:ℳ
		for col_index ∈ 1:ℛ

			old_value = matrix[row_index,col_index]
			if (old_value == 0.0)
				B[row_index,col_index] = 0
			else
				B[row_index,col_index] = 1
			end
		end
	end
	
	# return -
	return B
end

B = S |> binary_stoichiometric_matrix
RCA = transpose(B)*B
diag(RCA)
