#### Build the stoichiometric array

pidx = 5

function ingredients(path::String)
	
	# this is from the Julia source code (evalfile in base/loading.jl)
	# but with the modification that it returns the module instead of the last object
	name = Symbol("lib")
	m = Module(name)
	Core.eval(m,
        Expr(:toplevel,
             :(eval(x) = $(Expr(:core, :eval))($name, x)),
             :(include(x) = $(Expr(:top, :include))($name, x)),
             :(include(mapexpr::Function, x) = $(Expr(:top, :include))(mapexpr, $name, x)),
             :(include($path))))
	m
end

begin

	# import some packages -
	using PlutoUI
	using LinearAlgebra
	using RowEchelon
	using IterativeSolvers
	using Combinatorics
	using Plots
	using GLPK
	using PrettyTables
	
	# setup paths -
	const _PATH_TO_NOTEBOOK = pwd()
	const _PATH_TO_SRC = joinpath(_PATH_TO_NOTEBOOK,"src")

	# load the class lib as LectureLib -
	lib = ingredients(joinpath(_PATH_TO_SRC, "Include.jl"));

	# return -
	nothing
end

begin 

	# Setup a collection of reaction strings -
	reaction_array = Array{String,1}()

	# encode the reactions -
	# internal reactions -
	push!(reaction_array,"v₁, Aspartate+Citrulline, Argininosuccinate,false")
	push!(reaction_array,"v₂, Argininosuccinate, Fumarate+Arginine, false")
	push!(reaction_array,"v₃, Arginine, Ornithine+Urea, false")
	push!(reaction_array,"v₄, Ornithine+CarbamoylPhosphate, Citrulline, false")
	push!(reaction_array,"v₅, Citrulline, Arginine, false")

	# exchange reactions 
	push!(reaction_array,"b₁, ∅, CarbamoylPhosphate, false")
	push!(reaction_array,"b₂, ∅, Aspartate, false")
	push!(reaction_array,"b₃, Fumarate, ∅, false")
	push!(reaction_array,"b₄, Urea, ∅, false")
	
	# compute the stoichiometric matrix -
	# the optional expand arguement = should we split reversible reactions? (default: false)
	(S, species_array, reaction_name_array) = lib.build_stoichiometric_matrix(reaction_array);
	#expand=true
	# show -
	nothing
	
end


(ℳ,ℛ) = size(S)

species_array

S

#### Convex analysis: extreme pathways
